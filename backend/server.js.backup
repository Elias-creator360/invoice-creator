const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { createClient } = require('@supabase/supabase-js');

dotenv.config({ path: '../.env.local' });

const app = express();
const PORT = process.env.PORT || 3001;

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('Missing Supabase credentials');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey);

// Middleware
app.use(cors());
app.use(express.json());
  } else {
    db = new SQL.Database();
  }
  
  // Create tables
  db.run(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      first_name TEXT NOT NULL DEFAULT '',
      last_name TEXT NOT NULL DEFAULT '',
      email TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      company_name TEXT NOT NULL,
      role TEXT DEFAULT 'User' CHECK(role IN ('Admin', 'User')),
      is_active INTEGER DEFAULT 1,
      last_login DATETIME,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);
  
  // Add first_name and last_name columns if they don't exist (for existing databases)
  try {
    db.run(`ALTER TABLE users ADD COLUMN first_name TEXT NOT NULL DEFAULT ''`);
  } catch (e) {
    // Column already exists
  }
  try {
    db.run(`ALTER TABLE users ADD COLUMN last_name TEXT NOT NULL DEFAULT ''`);
  } catch (e) {
    // Column already exists
  }

  // Create roles table
  db.run(`
    CREATE TABLE IF NOT EXISTS roles (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT UNIQUE NOT NULL,
      description TEXT,
      is_system INTEGER DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Create permissions table
  db.run(`
    CREATE TABLE IF NOT EXISTS permissions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      page_name TEXT NOT NULL,
      page_path TEXT NOT NULL,
      description TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Create role_permissions table
  db.run(`
    CREATE TABLE IF NOT EXISTS role_permissions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      role_id INTEGER NOT NULL,
      permission_id INTEGER NOT NULL,
      access_level TEXT NOT NULL CHECK(access_level IN ('none', 'view', 'edit')),
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
      FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE,
      UNIQUE(role_id, permission_id)
    )
  `);

  // Create user_roles table
  db.run(`
    CREATE TABLE IF NOT EXISTS user_roles (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      role_id INTEGER NOT NULL,
      assigned_by INTEGER,
      assigned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
      FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
      FOREIGN KEY (assigned_by) REFERENCES users(id),
      UNIQUE(user_id, role_id)
    )
  `);

  // Customers table
  db.run(`
    CREATE TABLE IF NOT EXISTS customers (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      email TEXT,
      phone TEXT,
      address TEXT,
      city TEXT,
      state TEXT,
      zip TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id)
    )
  `);

  // Vendors table
  db.exec(`
    CREATE TABLE IF NOT EXISTS vendors (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      email TEXT,
      phone TEXT,
      address TEXT,
      city TEXT,
      state TEXT,
      zip TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id)
    )
  `);

  // Invoices table
  db.exec(`
    CREATE TABLE IF NOT EXISTS invoices (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      customer_id INTEGER NOT NULL,
      invoice_number TEXT UNIQUE NOT NULL,
      date DATE NOT NULL,
      due_date DATE NOT NULL,
      status TEXT DEFAULT 'draft',
      subtotal REAL NOT NULL,
      tax REAL DEFAULT 0,
      total REAL NOT NULL,
      notes TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id),
      FOREIGN KEY (customer_id) REFERENCES customers(id)
    )
  `);

  // Invoice items table
  db.exec(`
    CREATE TABLE IF NOT EXISTS invoice_items (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      invoice_id INTEGER NOT NULL,
      description TEXT NOT NULL,
      quantity REAL NOT NULL,
      rate REAL NOT NULL,
      amount REAL NOT NULL,
      FOREIGN KEY (invoice_id) REFERENCES invoices(id) ON DELETE CASCADE
    )
  `);

  // Expenses table
  db.exec(`
    CREATE TABLE IF NOT EXISTS expenses (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      vendor_id INTEGER,
      date DATE NOT NULL,
      category TEXT NOT NULL,
      description TEXT NOT NULL,
      amount REAL NOT NULL,
      payment_method TEXT,
      receipt_url TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id),
      FOREIGN KEY (vendor_id) REFERENCES vendors(id)
    )
  `);

  // Transactions table
  db.exec(`
    CREATE TABLE IF NOT EXISTS transactions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      date DATE NOT NULL,
      type TEXT NOT NULL,
      category TEXT NOT NULL,
      description TEXT NOT NULL,
      amount REAL NOT NULL,
      reference_id INTEGER,
      reference_type TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id)
    )
  `);

  console.log('Database initialized successfully');
  
  // Initialize default roles and permissions if they don't exist
  initializeDefaultRolesAndPermissions();
}

// Initialize default roles and permissions
function initializeDefaultRolesAndPermissions() {
  try {
    // Insert default roles
    const rolesCount = db.prepare('SELECT COUNT(*) as count FROM roles').get();
    if (rolesCount.count === 0) {
      const roleStmt = db.prepare('INSERT INTO roles (name, description, is_system) VALUES (?, ?, ?)');
      roleStmt.run('Admin', 'Full system access with all permissions', 1);
      roleStmt.run('User', 'Standard user with basic permissions', 1);
      roleStmt.run('Manager', 'Manager with extended permissions', 0);
      roleStmt.run('Accountant', 'Financial data access only', 0);
      roleStmt.run('Sales', 'Customer and invoice management', 0);
      console.log('Default roles created');
    }

    // Insert default permissions
    const permCount = db.prepare('SELECT COUNT(*) as count FROM permissions').get();
    if (permCount.count === 0) {
      const permStmt = db.prepare('INSERT INTO permissions (page_name, page_path, description) VALUES (?, ?, ?)');
      permStmt.run('Dashboard', '/dashboard', 'Main dashboard with statistics');
      permStmt.run('Customers', '/dashboard/customers', 'Customer management');
      permStmt.run('Products', '/dashboard/products', 'Product catalog management');
      permStmt.run('Invoices', '/dashboard/invoices', 'Invoice creation and management');
      permStmt.run('Expenses', '/dashboard/expenses', 'Expense tracking');
      permStmt.run('Vendors', '/dashboard/vendors', 'Vendor management');
      permStmt.run('Transactions', '/dashboard/transactions', 'Transaction history');
      permStmt.run('Reports', '/dashboard/reports', 'Financial reports');
      permStmt.run('Admin Panel', '/dashboard/admin', 'User and role management');
      console.log('Default permissions created');

      // Set up role permissions
      setupDefaultRolePermissions();
    }
  } catch (error) {
    console.error('Error initializing roles and permissions:', error);
  }
}

function setupDefaultRolePermissions() {
  try {
    const permissions = db.prepare('SELECT * FROM permissions').all();
    const rpStmt = db.prepare('INSERT OR IGNORE INTO role_permissions (role_id, permission_id, access_level) VALUES (?, ?, ?)');

    // Admin role - full access
    permissions.forEach(perm => {
      rpStmt.run(1, perm.id, 'edit');
    });

    // User role - limited access
    permissions.forEach(perm => {
      let access = 'view';
      if (['Dashboard', 'Reports', 'Transactions'].includes(perm.page_name)) {
        access = 'view';
      } else if (['Customers', 'Products', 'Invoices', 'Expenses', 'Vendors'].includes(perm.page_name)) {
        access = 'edit';
      } else if (perm.page_name === 'Admin Panel') {
        access = 'none';
      }
      rpStmt.run(2, perm.id, access);
    });

    // Manager role - most access except admin panel
    permissions.forEach(perm => {
      const access = perm.page_name === 'Admin Panel' ? 'none' : 'edit';
      rpStmt.run(3, perm.id, access);
    });

    // Accountant role - financial focus
    permissions.forEach(perm => {
      let access = 'view';
      if (['Expenses', 'Transactions', 'Reports', 'Invoices'].includes(perm.page_name)) {
        access = 'edit';
      } else if (['Products', 'Admin Panel'].includes(perm.page_name)) {
        access = 'none';
      }
      rpStmt.run(4, perm.id, access);
    });

    // Sales role - customer and invoice focus
    permissions.forEach(perm => {
      let access = 'view';
      if (['Customers', 'Invoices', 'Products'].includes(perm.page_name)) {
        access = 'edit';
      } else if (['Expenses', 'Vendors', 'Transactions', 'Admin Panel'].includes(perm.page_name)) {
        access = 'none';
      }
      rpStmt.run(5, perm.id, access);
    });

    console.log('Default role permissions set up');
  } catch (error) {
    console.error('Error setting up role permissions:', error);
  }
}

initDatabase();

// Auth middleware - Verify Supabase JWT token
async function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    console.log('Auth error: No token provided');
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    // Verify token with Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error || !user) {
      console.log('Auth error:', error?.message || 'Invalid token');
      return res.status(401).json({ error: 'Invalid token. Please log in again.' });
    }

    // Get user data from users table
    const { data: userData, error: userError } = await supabase
      .from('users')
      .select('*')
      .eq('email', user.email)
      .single();

    if (userError || !userData) {
      console.log('User lookup error:', userError?.message);
      return res.status(401).json({ error: 'User not found' });
    }

    if (!userData.is_active) {
      return res.status(403).json({ error: 'Account is inactive' });
    }

    req.userId = userData.id;
    req.userEmail = userData.email;
    req.userRole = userData.role;
    req.supabaseUser = user;
    next();
  } catch (error) {
    console.log('Auth error:', error.message);
    return res.status(401).json({ error: 'Authentication failed. Please log in again.' });
  }
}

// Admin middleware - only allows Admin users
function adminMiddleware(req, res, next) {
  if (req.userRole !== 'Admin') {
    return res.status(403).json({ error: 'Access denied. Admin role required.' });
  }
  next();
}

// Auth routes
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, companyName, role = 'User', firstName = '', lastName = '' } = req.body;
    
    // Validate role
    if (!['Admin', 'User'].includes(role)) {
      return res.status(400).json({ error: 'Invalid role. Must be Admin or User' });
    }
    
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const stmt = db.prepare('INSERT INTO users (first_name, last_name, email, password, company_name, role) VALUES (?, ?, ?, ?, ?, ?)');
    const result = stmt.run(firstName, lastName, email, hashedPassword, companyName, role);
    
    const token = jwt.sign({ userId: result.lastInsertRowid, role }, JWT_SECRET, { expiresIn: '7d' });
    
    // Update last login
    db.prepare('UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?').run(result.lastInsertRowid);
    
    res.json({ token, userId: result.lastInsertRowid, role });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email);
    
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    if (!user.is_active) {
      return res.status(401).json({ error: 'Account is deactivated' });
    }
    
    if (!(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const token = jwt.sign({ userId: user.id, role: user.role }, JWT_SECRET, { expiresIn: '7d' });
    
    // Update last login
    db.prepare('UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?').run(user.id);
    
    res.json({ 
      token, 
      userId: user.id, 
      role: user.role,
      email: user.email,
      companyName: user.company_name
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get current user
app.get('/api/auth/me', authMiddleware, (req, res) => {
  try {
    const user = db.prepare('SELECT id, first_name, last_name, email, company_name, role, is_active, last_login, created_at FROM users WHERE id = ?').get(req.userId);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(user);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Logout (client-side mainly, but we can track it)
app.post('/api/auth/logout', authMiddleware, (req, res) => {
  try {
    // In a more complex system, you would invalidate the token here
    // For now, we just acknowledge the logout
    res.json({ success: true, message: 'Logged out successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Customer routes
app.get('/api/customers', authMiddleware, (req, res) => {
  try {
    const customers = db.prepare('SELECT * FROM customers WHERE user_id = ? ORDER BY created_at DESC').all(req.userId);
    res.json(customers);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/customers', authMiddleware, (req, res) => {
  try {
    const { name, email, phone, address, city, state, zip } = req.body;
    const stmt = db.prepare('INSERT INTO customers (user_id, name, email, phone, address, city, state, zip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)');
    const result = stmt.run(req.userId, name, email, phone, address, city, state, zip);
    res.json({ id: result.lastInsertRowid, ...req.body });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.put('/api/customers/:id', authMiddleware, (req, res) => {
  try {
    const { name, email, phone, address, city, state, zip } = req.body;
    const stmt = db.prepare('UPDATE customers SET name = ?, email = ?, phone = ?, address = ?, city = ?, state = ?, zip = ? WHERE id = ? AND user_id = ?');
    stmt.run(name, email, phone, address, city, state, zip, req.params.id, req.userId);
    res.json({ id: req.params.id, ...req.body });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.delete('/api/customers/:id', authMiddleware, (req, res) => {
  try {
    db.prepare('DELETE FROM customers WHERE id = ? AND user_id = ?').run(req.params.id, req.userId);
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Vendor routes
app.get('/api/vendors', authMiddleware, (req, res) => {
  try {
    const vendors = db.prepare('SELECT * FROM vendors WHERE user_id = ? ORDER BY created_at DESC').all(req.userId);
    res.json(vendors);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/vendors', authMiddleware, (req, res) => {
  try {
    const { name, email, phone, address, city, state, zip } = req.body;
    const stmt = db.prepare('INSERT INTO vendors (user_id, name, email, phone, address, city, state, zip) VALUES (?, ?, ?, ?, ?, ?, ?, ?)');
    const result = stmt.run(req.userId, name, email, phone, address, city, state, zip);
    res.json({ id: result.lastInsertRowid, ...req.body });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Invoice routes
app.get('/api/invoices', authMiddleware, (req, res) => {
  try {
    const invoices = db.prepare(`
      SELECT i.*, c.name as customer_name 
      FROM invoices i 
      JOIN customers c ON i.customer_id = c.id 
      WHERE i.user_id = ? 
      ORDER BY i.created_at DESC
    `).all(req.userId);
    res.json(invoices);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/invoices/:id', authMiddleware, (req, res) => {
  try {
    const invoice = db.prepare(`
      SELECT i.*, c.name as customer_name, c.email as customer_email, c.address, c.city, c.state, c.zip
      FROM invoices i 
      JOIN customers c ON i.customer_id = c.id 
      WHERE i.id = ? AND i.user_id = ?
    `).get(req.params.id, req.userId);
    
    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }
    
    const items = db.prepare('SELECT * FROM invoice_items WHERE invoice_id = ?').all(req.params.id);
    invoice.items = items;
    
    res.json(invoice);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/invoices', authMiddleware, (req, res) => {
  try {
    const { customer_id, invoice_number, date, due_date, status, items, notes } = req.body;
    
    const subtotal = items.reduce((sum, item) => sum + item.amount, 0);
    const tax = subtotal * 0.1; // 10% tax example
    const total = subtotal + tax;
    
    db.prepare('BEGIN').run();
    
    try {
      const stmt = db.prepare('INSERT INTO invoices (user_id, customer_id, invoice_number, date, due_date, status, subtotal, tax, total, notes) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)');
      const result = stmt.run(req.userId, customer_id, invoice_number, date, due_date, status || 'draft', subtotal, tax, total, notes);
      
      const invoiceId = result.lastInsertRowid;
      
      const itemStmt = db.prepare('INSERT INTO invoice_items (invoice_id, description, quantity, rate, amount) VALUES (?, ?, ?, ?, ?)');
      for (const item of items) {
        itemStmt.run(invoiceId, item.description, item.quantity, item.rate, item.amount);
      }
      
      db.prepare('COMMIT').run();
      
      res.json({ id: invoiceId, invoice_number, subtotal, tax, total });
    } catch (error) {
      db.prepare('ROLLBACK').run();
      throw error;
    }
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Expense routes
app.get('/api/expenses', authMiddleware, (req, res) => {
  try {
    const expenses = db.prepare(`
      SELECT e.*, v.name as vendor_name 
      FROM expenses e 
      LEFT JOIN vendors v ON e.vendor_id = v.id 
      WHERE e.user_id = ? 
      ORDER BY e.date DESC
    `).all(req.userId);
    res.json(expenses);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/expenses', authMiddleware, (req, res) => {
  try {
    const { vendor_id, date, category, description, amount, payment_method } = req.body;
    const stmt = db.prepare('INSERT INTO expenses (user_id, vendor_id, date, category, description, amount, payment_method) VALUES (?, ?, ?, ?, ?, ?, ?)');
    const result = stmt.run(req.userId, vendor_id, date, category, description, amount, payment_method);
    res.json({ id: result.lastInsertRowid, ...req.body });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Dashboard stats
app.get('/api/dashboard/stats', authMiddleware, (req, res) => {
  try {
    const totalRevenue = db.prepare('SELECT SUM(total) as total FROM invoices WHERE user_id = ? AND status = "paid"').get(req.userId);
    const totalExpenses = db.prepare('SELECT SUM(amount) as total FROM expenses WHERE user_id = ?').get(req.userId);
    const totalCustomers = db.prepare('SELECT COUNT(*) as count FROM customers WHERE user_id = ?').get(req.userId);
    const pendingInvoices = db.prepare('SELECT COUNT(*) as count FROM invoices WHERE user_id = ? AND status = "sent"').get(req.userId);
    
    res.json({
      revenue: totalRevenue.total || 0,
      expenses: totalExpenses.total || 0,
      profit: (totalRevenue.total || 0) - (totalExpenses.total || 0),
      customers: totalCustomers.count || 0,
      pendingInvoices: pendingInvoices.count || 0
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Recent activity
app.get('/api/dashboard/activity', authMiddleware, (req, res) => {
  try {
    const recentInvoices = db.prepare(`
      SELECT 'invoice' as type, i.invoice_number as reference, i.total as amount, i.created_at as date, c.name as entity
      FROM invoices i
      JOIN customers c ON i.customer_id = c.id
      WHERE i.user_id = ?
      ORDER BY i.created_at DESC
      LIMIT 5
    `).all(req.userId);
    
    const recentExpenses = db.prepare(`
      SELECT 'expense' as type, e.description as reference, e.amount, e.date, COALESCE(v.name, 'No vendor') as entity
      FROM expenses e
      LEFT JOIN vendors v ON e.vendor_id = v.id
      WHERE e.user_id = ?
      ORDER BY e.created_at DESC
      LIMIT 5
    `).all(req.userId);
    
    const activity = [...recentInvoices, ...recentExpenses]
      .sort((a, b) => new Date(b.date) - new Date(a.date))
      .slice(0, 10);
    
    res.json(activity);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// ADMIN API ROUTES
// ============================================

// Get all users (Admin only)
app.get('/api/admin/users', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const users = db.prepare(`
      SELECT 
        u.id,
        u.first_name,
        u.last_name,
        u.email, 
        u.company_name, 
        u.role, 
        u.is_active, 
        u.last_login, 
        u.created_at,
        GROUP_CONCAT(r.name) as roles
      FROM users u
      LEFT JOIN user_roles ur ON u.id = ur.user_id
      LEFT JOIN roles r ON ur.role_id = r.id
      GROUP BY u.id
      ORDER BY u.created_at DESC
    `).all();
    
    res.json(users.map(user => ({
      ...user,
      roles: user.roles ? user.roles.split(',') : []
    })));
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get single user details (Admin only)
app.get('/api/admin/users/:id', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const user = db.prepare(`
      SELECT id, first_name, last_name, email, company_name, role, is_active, last_login, created_at 
      FROM users 
      WHERE id = ?
    `).get(req.params.id);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Get user's roles
    const userRoles = db.prepare(`
      SELECT r.id, r.name, r.description
      FROM roles r
      JOIN user_roles ur ON r.id = ur.role_id
      WHERE ur.user_id = ?
    `).all(req.params.id);
    
    user.assignedRoles = userRoles;
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create new user (Admin only)
app.post('/api/admin/users', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { email, password, companyName, role = 'User', isActive = true, roleIds = [], firstName = '', lastName = '' } = req.body;
    
    if (!email || !password || !companyName) {
      return res.status(400).json({ error: 'Email, password, and company name are required' });
    }
    
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const stmt = db.prepare('INSERT INTO users (first_name, last_name, email, password, company_name, role, is_active) VALUES (?, ?, ?, ?, ?, ?, ?)');
    const result = stmt.run(firstName, lastName, email, hashedPassword, companyName, role, isActive ? 1 : 0);
    
    const userId = result.lastInsertRowid;
    
    // Assign roles if provided
    if (roleIds.length > 0) {
      const roleStmt = db.prepare('INSERT INTO user_roles (user_id, role_id, assigned_by) VALUES (?, ?, ?)');
      roleIds.forEach(roleId => {
        roleStmt.run(userId, roleId, req.userId);
      });
    }
    
    res.json({ 
      id: userId, 
      email, 
      companyName, 
      role, 
      isActive,
      message: 'User created successfully' 
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Update user (Admin only)
app.put('/api/admin/users/:id', authMiddleware, adminMiddleware, async (req, res) => {
  try {
    const { email, companyName, role, isActive, password, firstName, lastName } = req.body;
    const userId = req.params.id;
    
    // Build dynamic update query
    const updates = [];
    const values = [];
    
    if (firstName !== undefined) {
      updates.push('first_name = ?');
      values.push(firstName);
    }
    if (lastName !== undefined) {
      updates.push('last_name = ?');
      values.push(lastName);
    }
    if (email !== undefined) {
      updates.push('email = ?');
      values.push(email);
    }
    if (companyName !== undefined) {
      updates.push('company_name = ?');
      values.push(companyName);
    }
    if (role !== undefined) {
      updates.push('role = ?');
      values.push(role);
    }
    if (isActive !== undefined) {
      updates.push('is_active = ?');
      values.push(isActive ? 1 : 0);
    }
    if (password) {
      updates.push('password = ?');
      const hashedPassword = await bcrypt.hash(password, 10);
      values.push(hashedPassword);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }
    
    values.push(userId);
    const query = `UPDATE users SET ${updates.join(', ')} WHERE id = ?`;
    
    db.prepare(query).run(...values);
    
    res.json({ message: 'User updated successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Delete user (Admin only)
app.delete('/api/admin/users/:id', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const userId = req.params.id;
    
    // Prevent admin from deleting themselves
    if (parseInt(userId) === req.userId) {
      return res.status(400).json({ error: 'Cannot delete your own account' });
    }
    
    db.prepare('DELETE FROM users WHERE id = ?').run(userId);
    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get all roles
app.get('/api/admin/roles', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const roles = db.prepare(`
      SELECT 
        r.*,
        COUNT(DISTINCT ur.user_id) as user_count,
        COUNT(DISTINCT rp.permission_id) as permission_count
      FROM roles r
      LEFT JOIN user_roles ur ON r.id = ur.role_id
      LEFT JOIN role_permissions rp ON r.id = rp.role_id
      GROUP BY r.id
      ORDER BY r.is_system DESC, r.created_at DESC
    `).all();
    
    res.json(roles);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get single role details
app.get('/api/admin/roles/:id', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const role = db.prepare('SELECT * FROM roles WHERE id = ?').get(req.params.id);
    
    if (!role) {
      return res.status(404).json({ error: 'Role not found' });
    }
    
    // Get role permissions
    const permissions = db.prepare(`
      SELECT p.*, rp.access_level
      FROM permissions p
      LEFT JOIN role_permissions rp ON p.id = rp.permission_id AND rp.role_id = ?
    `).all(req.params.id);
    
    role.permissions = permissions;
    res.json(role);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create new role (Admin only)
app.post('/api/admin/roles', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const { name, description } = req.body;
    
    if (!name) {
      return res.status(400).json({ error: 'Role name is required' });
    }
    
    const stmt = db.prepare('INSERT INTO roles (name, description, is_system) VALUES (?, ?, 0)');
    const result = stmt.run(name, description || '');
    
    res.json({ 
      id: result.lastInsertRowid, 
      name, 
      description,
      message: 'Role created successfully' 
    });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Update role (Admin only, cannot update system roles)
app.put('/api/admin/roles/:id', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const roleId = req.params.id;
    const { name, description } = req.body;
    
    // Check if it's a system role
    const role = db.prepare('SELECT is_system FROM roles WHERE id = ?').get(roleId);
    if (!role) {
      return res.status(404).json({ error: 'Role not found' });
    }
    if (role.is_system === 1) {
      return res.status(400).json({ error: 'Cannot modify system roles' });
    }
    
    const updates = [];
    const values = [];
    
    if (name !== undefined) {
      updates.push('name = ?');
      values.push(name);
    }
    if (description !== undefined) {
      updates.push('description = ?');
      values.push(description);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }
    
    values.push(roleId);
    const query = `UPDATE roles SET ${updates.join(', ')}, updated_at = CURRENT_TIMESTAMP WHERE id = ?`;
    
    db.prepare(query).run(...values);
    res.json({ message: 'Role updated successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Delete role (Admin only, cannot delete system roles)
app.delete('/api/admin/roles/:id', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const roleId = req.params.id;
    
    const role = db.prepare('SELECT is_system FROM roles WHERE id = ?').get(roleId);
    if (!role) {
      return res.status(404).json({ error: 'Role not found' });
    }
    if (role.is_system === 1) {
      return res.status(400).json({ error: 'Cannot delete system roles' });
    }
    
    db.prepare('DELETE FROM roles WHERE id = ?').run(roleId);
    res.json({ message: 'Role deleted successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get all permissions
app.get('/api/admin/permissions', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const permissions = db.prepare('SELECT * FROM permissions ORDER BY page_name').all();
    res.json(permissions);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update role permissions (Admin only)
app.put('/api/admin/roles/:id/permissions', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const roleId = req.params.id;
    const { permissions } = req.body; // Array of { permission_id, access_level }
    
    if (!Array.isArray(permissions)) {
      return res.status(400).json({ error: 'Permissions must be an array' });
    }
    
    // Delete existing permissions for this role
    db.prepare('DELETE FROM role_permissions WHERE role_id = ?').run(roleId);
    
    // Insert new permissions
    const stmt = db.prepare('INSERT INTO role_permissions (role_id, permission_id, access_level) VALUES (?, ?, ?)');
    permissions.forEach(perm => {
      if (perm.access_level !== 'none') {
        stmt.run(roleId, perm.permission_id, perm.access_level);
      }
    });
    
    res.json({ message: 'Role permissions updated successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Assign roles to user (Admin only)
app.post('/api/admin/users/:id/roles', authMiddleware, adminMiddleware, (req, res) => {
  try {
    const userId = req.params.id;
    const { roleIds } = req.body; // Array of role IDs
    
    if (!Array.isArray(roleIds)) {
      return res.status(400).json({ error: 'roleIds must be an array' });
    }
    
    // Delete existing role assignments
    db.prepare('DELETE FROM user_roles WHERE user_id = ?').run(userId);
    
    // Assign new roles
    const stmt = db.prepare('INSERT INTO user_roles (user_id, role_id, assigned_by) VALUES (?, ?, ?)');
    roleIds.forEach(roleId => {
      stmt.run(userId, roleId, req.userId);
    });
    
    res.json({ message: 'User roles updated successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get user permissions
app.get('/api/auth/permissions', authMiddleware, (req, res) => {
  try {
    const permissions = db.prepare(`
      SELECT DISTINCT
        p.page_name,
        p.page_path,
        MAX(
          CASE rp.access_level
            WHEN 'edit' THEN 3
            WHEN 'view' THEN 2
            WHEN 'none' THEN 1
            ELSE 0
          END
        ) as access_level_num
      FROM permissions p
      LEFT JOIN role_permissions rp ON p.id = rp.permission_id
      LEFT JOIN user_roles ur ON rp.role_id = ur.role_id
      WHERE ur.user_id = ?
      GROUP BY p.id, p.page_name, p.page_path
    `).all(req.userId);
    
    // Convert numeric access level back to string
    const formattedPermissions = permissions.map(perm => ({
      page_name: perm.page_name,
      page_path: perm.page_path,
      access_level: perm.access_level_num === 3 ? 'edit' : perm.access_level_num === 2 ? 'view' : 'none'
    }));
    
    // If user is Admin (legacy role field), give full access
    const user = db.prepare('SELECT role FROM users WHERE id = ?').get(req.userId);
    if (user && user.role === 'Admin') {
      const allPermissions = db.prepare('SELECT page_name, page_path FROM permissions').all();
      return res.json(allPermissions.map(p => ({ ...p, access_level: 'edit' })));
    }
    
    res.json(formattedPermissions);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
